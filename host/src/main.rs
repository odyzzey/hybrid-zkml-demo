// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    METHOD_ELF, METHOD_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};
use ml::{Layer, Neuron};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // 8x8x8 neural network, final layer in the zkVM
    let input_layer = random_layer(8);
    let middle_layer = random_layer(8);
    let output_layer = random_layer(8); // going into the risc0_zkvm

    let mut builder = ExecutorEnv::builder();

    // Virtual layer goes into the zkVM, here it's just the final layer
    // for simplicity.
    let env = builder
        .write(&output_layer)
        .unwrap();

    let input  = random_input(8);

    // The remaining layers stay on the host and forward as normal.
    let layer_one_output = input_layer.forward(&input);
    let layer_two_output = middle_layer.forward(&layer_one_output);

    // Once we reach the virtual layer, the same thing happens in the zkVM.
    let env = env.write(&layer_two_output)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();

    let prove_info = prover
        .prove(env, METHOD_ELF)
        .unwrap();

    let receipt = prove_info.receipt;

    // If we wanted a virtual layer in the middle, the output here could be sent
    // back to the host and used as input to the next layer.
    let _output: Vec<f32> = receipt.journal.decode().unwrap();

    receipt
        .verify(METHOD_ID)
        .unwrap();
}

fn random_layer(size: usize) -> Layer {
    let mut neurons = Vec::with_capacity(size);
    for _ in 0..size {
        let mut weights = Vec::with_capacity(size);
        for _ in 0..size {
            weights.push(rand::random());
        }
        neurons.push(Neuron::new(weights, rand::random()));
    }
    Layer::new(neurons)
}

fn random_input(size: usize) -> Vec<f32> {
    (0..size).map(|_| rand::random()).collect()
}
